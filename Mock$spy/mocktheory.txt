üß© MOCKING EXAMPLE ‚Äî COMPLETE
Imagine a simple real-world scenario:

You have a function getUserStatus that calls an external API fetchUser:

// real code
async function getUserStatus(fetchUser) {
    const user = await fetchUser();
    if (!user) return 'NO USER';
    if (user.active) return 'ACTIVE';
    return 'INACTIVE';
}

Step 1: Create a mock for the dependency
const fetchUser = jest.fn();  // ‚úÖ This is our mock dependency

Step 2: Write tests for different scenarios
test('user is active', async () => {
    // Setup: define what the mock should return
    fetchUser.mockResolvedValue({ name: 'Alice', active: true });

    // Call the real function under test
    const result = await getUserStatus(fetchUser);

    // Assert the expected behavior
    expect(result).toBe('ACTIVE');
});

test('user is inactive', async () => {
    fetchUser.mockResolvedValue({ name: 'Bob', active: false });

    const result = await getUserStatus(fetchUser);

    expect(result).toBe('INACTIVE');
});

test('no user returned', async () => {
    fetchUser.mockResolvedValue(null);  // simulate API returning nothing

    const result = await getUserStatus(fetchUser);

    expect(result).toBe('NO USER');
});

Step 3: Explanation of each part
Part	Purpose
jest.fn()	Creates a fake function that we can control
mockResolvedValue()	Makes the mock return a resolved Promise with the value we choose
getUserStatus(fetchUser)	The real function we want to test
expect(result).toBe(...)	Assert the outcome of the real function, not the mock
Step 4: Visual Diagram
        Test starts
             ‚îÇ
             ‚ñº
    fetchUser mock created
             ‚îÇ
             ‚ñº
    mockResolvedValue({name:'Alice', active:true})
             ‚îÇ
             ‚ñº
   getUserStatus calls fetchUser()  ‚Üê Real function uses mock
             ‚îÇ
             ‚ñº
       fetchUser returns {name:'Alice', active:true}
             ‚îÇ
             ‚ñº
   getUserStatus checks `active` field
             ‚îÇ
             ‚ñº
       Returns 'ACTIVE'
             ‚îÇ
             ‚ñº
   expect(result).toBe('ACTIVE') ‚úÖ Test passes


üí° Notice: The mock only controls fetchUser‚Äôs behavior, it doesn‚Äôt test fetchUser itself. We test getUserStatus.

Step 5: Optional: Multiple calls with Once
test('multiple calls', async () => {
    fetchUser
        .mockResolvedValueOnce({ name: 'Alice', active: true })
        .mockResolvedValueOnce({ name: 'Bob', active: false });

    expect(await getUserStatus(fetchUser)).toBe('ACTIVE');
    expect(await getUserStatus(fetchUser)).toBe('INACTIVE');
});


‚úÖ This is how you simulate real sequences of API calls.

üîë Key Takeaways

Mocks are for dependencies only ‚Äì you never test the mock itself.

Control return values using mockResolvedValue / mockRejectedValue / mockReturnValue.

Assert the real function‚Äôs output, not the mock.

Use Once to simulate multiple calls with different outcomes.

Visualize it as: mock ‚Üí function under test ‚Üí assert result.

If you want, I can make a full visual cheat sheet with all mock types (ReturnValue, ResolvedValue, RejectedValue, Implementation) in one diagram so it‚Äôs impossible to get confused again.

Do you want me to make that?

yes

Perfect! Let‚Äôs make a full visual cheat sheet for Jest mocks ‚Äî all types, when to use them, and how they flow. This will eliminate all confusion.

üß© Jest Mock Cheat Sheet ‚Äî Visual & Explained
üéØ Core Concept

Flow:

[TEST SETUP] --> [MOCK BEHAVIOR] --> [FUNCTION UNDER TEST] --> [ASSERT OUTPUT]


Mocks control dependencies, we never test the mock itself.

1Ô∏è‚É£ Creating a Mock
const fetchUser = jest.fn();


Creates a fake function

Records calls & arguments

Can return anything we want

Visual:

fetchUser()  <-- initially does nothing

2Ô∏è‚É£ Basic Return Values
Method	What it does	Example	Visual
mockReturnValue(val)	Always returns val	fn.mockReturnValue(5)	fn() ‚Üí 5, fn() ‚Üí 5
mockReturnValueOnce(val)	Returns val only once	fn.mockReturnValueOnce(5)	1st call ‚Üí 5, 2nd call ‚Üí undefined

Flow Diagram:

Call 1 ‚Üí returns 5
Call 2 ‚Üí returns undefined

3Ô∏è‚É£ Async Functions
Method	What it does	Example	Visual
mockResolvedValue(val)	Always returns Promise.resolve(val)	fn.mockResolvedValue('OK')	await fn() ‚Üí 'OK'
mockRejectedValue(err)	Always returns Promise.reject(err)	fn.mockRejectedValue(new Error('FAIL'))	await fn() ‚Üí throws 'FAIL'
mockResolvedValueOnce(val)	Only resolves once	fn.mockResolvedValueOnce('OK')	1st call ‚Üí 'OK', 2nd call ‚Üí undefined

Flow Diagram:

1st call ‚Üí resolves 'OK'
2nd call ‚Üí resolves undefined

4Ô∏è‚É£ Mock Implementation (Custom behavior)
fn.mockImplementation((x) => x * 2);


Useful when output depends on input

Can also be async:

fn.mockImplementation(async (x) => x * 2);


Visual:

fn(3) ‚Üí 6
fn(5) ‚Üí 10

5Ô∏è‚É£ Multiple Calls / Sequence
fn
  .mockResolvedValueOnce('A')
  .mockResolvedValueOnce('B');


Flow:

Call 1 ‚Üí 'A'
Call 2 ‚Üí 'B'
Call 3 ‚Üí undefined


Perfect for simulating retries or API sequences

6Ô∏è‚É£ Spy vs Mock
Type	Does it call original?	Can override?
Spy (jest.spyOn)	Yes (by default)	Yes (.mockResolvedValue)
Mock (jest.fn)	No	Yes

Flow:

realFunction() ‚Üí original logic
spy ‚Üí can watch OR override
mock ‚Üí replaces function completely

7Ô∏è‚É£ Mocking Modules
jest.mock('./api', () => ({
  fetchUser: jest.fn(),
}));


Replace entire module with mocks

Control return values in tests

Visual:

Test ----> Mocked module ----> Function under test

8Ô∏è‚É£ Clearing & Resetting
Method	Clears calls?	Clears return values?	Restores original?
clearAllMocks()	‚úÖ	‚ùå	‚ùå
resetAllMocks()	‚úÖ	‚úÖ	‚ùå
restoreAllMocks()	‚ùå	‚ùå	‚úÖ

Tip:
afterEach(() => jest.clearAllMocks()) prevents leakage across tests.

9Ô∏è‚É£ Mindset Cheat Sheet
[MOCK] ‚Üí controls dependency output
[FUNCT] ‚Üí real function under test
[ASSERT] ‚Üí only care about output/behavior


‚úÖ Mocks = helpers
‚úÖ Function under test = real logic
‚úÖ Assert = result of function, never the mock itself

üîπ Example Combined (All Concepts)
const fetchUser = jest.fn();

test('multiple cases', async () => {
    fetchUser
      .mockResolvedValueOnce({ active: true })   // 1st call
      .mockResolvedValueOnce({ active: false })  // 2nd call
      .mockResolvedValueOnce(null);              // 3rd call

    const getUserStatus = async (fn) => {
        const user = await fn();
        if (!user) return 'NO USER';
        return user.active ? 'ACTIVE' : 'INACTIVE';
    }

    expect(await getUserStatus(fetchUser)).toBe('ACTIVE');
    expect(await getUserStatus(fetchUser)).toBe('INACTIVE');
    expect(await getUserStatus(fetchUser)).toBe('NO USER');
});


Diagram Flow:

Test Start
    ‚îÇ
    ‚ñº
fetchUser mock created
    ‚îÇ
    ‚ñº
mockResolvedValueOnce('ACTIVE') ‚Üí call 1 ‚Üí 'ACTIVE'
mockResolvedValueOnce('INACTIVE') ‚Üí call 2 ‚Üí 'INACTIVE'
mockResolvedValueOnce(null) ‚Üí call 3 ‚Üí 'NO USER'
    ‚îÇ
    ‚ñº
getUserStatus() ‚Üí asserts output each time


üí° Key Takeaways

One dependency ‚Üí multiple behaviors with Once

Mock controls dependency, never your function under test

Always assert real function output

Clear mocks between tests to prevent leakage